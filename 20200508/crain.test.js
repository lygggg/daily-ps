/*
이해
- 게임화면은 1x1의 크기로 이루어진 NxN 크기의 정사각 격자이다.
- 각 격자칸에는 인형이 들어있다. 인형이 없는 칸은 빈칸이다.
- 모든 인형은 1x1의 크기를 차지하며 격자의 가장 아래칸부터 쌓여있다.
- 크레인을 좌우로 움직여서 멈춘위치의 가장 위에 있는 인형을 집을 수 있다.
- 집어올린 인형은 바구니에 쌓이는데 가장 아래칸부터 순서대로 쌓인다.
- 2번 연속해서 쌓이게 되면 바구니에서 사라진다.
-  격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨
- 위치가 담긴 배열 moves 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 리턴

조건
- 2차원 배열의 크기는 5x5이상 30x30이하
- board칸에는 각 0이상 100이하의 정수
- 넣을때마다 검사해서 터트려준다.

계획
일단 2차원배열에서 moves의 자리에 있는 값을 차례대로 새로운 배열 result에 넣어준다,
뽑은게 0이면 넣지 않는다.
넣기전에 바구니에 연속된 결과값이 있는지 확인해주고 없으면 다시 뽑는다.
구하려고 하는 값
크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 

*/
const crain = (board, moves) => {
  let ex = 0;
  let resultArr = [];
  // console.log(board[3][0])
  moves.forEach((e) => {
    let count = 0;

    while (count < board.length) {
      if (board[count][e - 1] !== 0) {
        
        resultArr.push(board[count][e - 1]);
        board[count][e - 1] = 0;
        resultArr.filter((val, index) => {
            if (val == resultArr[index + 1]) {
              ex += 2;
              resultArr.splice(index, index+1);
            }
          });
        return;
      }

      count++;
    }

  });
  return ex; // 구하려고 하는값
};

test("crain", () => {
  expect(
    crain(
      [
        [0, 0, 0, 0, 0], // [0][0] [0][1] [0][2] [0][3] [0][4] [0][5]
        [0, 0, 1, 0, 3], // [1][0] [1][1] [1][2] [1][3] [1][4] [1][5]
        [0, 2, 5, 0, 1], // [2][0] [2][1] [2][2] [2][3] [2][4] [2][5]
        [4, 2, 4, 4, 2], // [3][0] [3][1] [3][2] [3][3] [3][4] [3][5]
        [3, 5, 1, 3, 1], // [4][0] [4][1] [4][2] [4][3] [4][4] [4][5]
      ],
      [1, 5, 3, 5, 1, 2, 1, 4]
    )
    // 4 3 1 1 3 2  4
    // 4 3 1 1 4 2  3
  ).toBe(4);
});
